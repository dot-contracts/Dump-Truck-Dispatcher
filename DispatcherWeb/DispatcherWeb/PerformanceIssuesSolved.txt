PERFORMANCE ISSUES SOLVED - DISPATCHER WEB APPLICATION

The DispatcherWeb application, a multi-tenant ASP.NET MVC application using .NET Core 9 and the ABP framework, was experiencing periodic hangs despite running on three P3V3 Azure App Service instances with low resource utilization (less than 10% CPU and 30% memory). The database server was also oversized with under 5% CPU utilization, yet application traces showed 99+% of time spent waiting during hang periods. Through comprehensive analysis and implementation of deep diagnostics and performance optimizations, we identified and resolved several critical bottlenecks that were causing the application to become unresponsive.

The primary issue identified was thread pool starvation, which occurs when the application exhausts available worker threads in the .NET thread pool, causing requests to queue up and the application to appear hung. This was addressed through the implementation of a dedicated ThreadPoolMonitoringService that continuously monitors thread pool health and provides real-time alerts when utilization exceeds 80% or reaches critical levels above 90%. The service tracks both worker thread and completion port thread utilization, providing detailed metrics to Application Insights for proactive monitoring. Additionally, we configured the thread pool with optimized minimum and maximum thread counts based on processor count to prevent starvation scenarios.

Database connection pool exhaustion was another critical issue contributing to the performance problems. The application was experiencing connection pool depletion, causing database operations to queue up and block the thread pool. This was resolved by optimizing the connection string configuration in appsettings.json, increasing the minimum pool size to 20 connections and maximum pool size to 200, while also extending the command timeout to 60 seconds and enabling retry on failure with a maximum retry count of 3. These changes ensure that database connections are readily available and resilient to transient failures, significantly reducing the likelihood of connection-related blocking.

The N+1 query problem in the SetOrderLineIsComplete method was identified as a significant performance bottleneck. The original implementation was processing order lines individually within a loop, resulting in multiple database round trips and inefficient resource utilization. This was solved by implementing a new SetOrderLineIsCompleteBatch method that processes multiple order lines in a single, batched database operation. The batch method retrieves all relevant order lines in one query, updates them in memory, and performs a single SaveChanges operation, dramatically reducing database calls from potentially hundreds to just one per batch operation. This optimization not only improves performance but also reduces database server load and connection pool pressure.

Comprehensive performance monitoring was implemented to provide real-time visibility into application health and performance bottlenecks. The EnhancedPerformanceMonitoringMiddleware captures detailed metrics for every HTTP request, including request duration, thread pool state at the start and end of each request, and thread utilization patterns. This middleware replaces the basic performance monitoring and provides context-rich data that helps identify when thread pool starvation is occurring during request processing. The middleware tracks slow requests (over 1000ms) and high thread pool utilization scenarios, enabling proactive detection of performance degradation before it affects user experience.

The Account/Login method was enhanced with detailed telemetry to monitor authentication performance and identify potential bottlenecks in the login process. Comprehensive tracking was added for various login scenarios including successful logins, password change requirements, two-factor authentication, and login failures. This monitoring helps identify if authentication-related operations are contributing to the overall performance issues and provides insights into user experience during login attempts.

Application Insights integration was significantly enhanced to provide comprehensive monitoring and alerting capabilities. Critical alerts were configured for thread pool exhaustion, slow requests, high thread pool utilization, request error rates, and database connection pool issues. These alerts enable immediate notification when performance thresholds are exceeded, allowing for proactive intervention before users experience service degradation. The monitoring infrastructure provides both real-time dashboards and historical trend analysis to identify patterns in performance issues.

The implementation of these solutions has created a robust monitoring and optimization framework that addresses the root causes of the periodic hangs. The thread pool monitoring service provides continuous visibility into thread pool health, while the enhanced middleware captures detailed request-level performance data. The batch processing optimization for SetOrderLineIsComplete eliminates the N+1 query problem, and the database connection pool optimizations ensure reliable database connectivity. Together, these improvements create a more resilient application architecture that can handle increased load while providing early warning systems for potential performance issues. The comprehensive telemetry and alerting system ensures that performance problems can be detected and addressed proactively, minimizing the impact on end users and maintaining the application's reliability in production environments. 